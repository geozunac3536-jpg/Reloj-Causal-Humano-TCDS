<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Reloj Causal Humano — TCDS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #050713;
      --bg-alt: #0b0f1f;
      --fg: #f5f7ff;
      --accent: #35e0ff;
      --accent2: #ff6bff;
      --danger: #ff6b6b;
      --ok: #4ade80;
      --card-radius: 20px;
      --shadow-soft: 0 20px 50px rgba(0,0,0,0.6);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
                   "SF Pro Text", "Roboto", "Segoe UI", sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #141b33 0%, #050713 45%, #01010a 100%);
      color: var(--fg);
      min-height: 100dvh;
      padding: 16px;
      display: flex;
      flex-direction: column;
    }

    .shell {
      max-width: 1100px;
      margin: auto;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    /* ==================== RELOJ CAUSAL GRANDE ==================== */
    .big-clock {
      background: radial-gradient(circle at center, #182546 0%, #050713 70%);
      border-radius: 32px;
      padding: 24px;
      box-shadow: var(--shadow-soft);
      border: 1px solid rgba(255,255,255,0.06);
      position: relative;
      overflow: hidden;
    }

    .big-clock svg {
      width: 100%;
      height: auto;
      display: block;
    }

    .big-clock.ready {
      box-shadow:
        0 0 30px rgba(56,189,248,0.7),
        0 0 80px rgba(59,130,246,0.9);
    }

    /* ==================== TARJETAS ==================== */
    .cards-row {
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr);
      gap: 12px;
    }

    @media (max-width: 840px) {
      .cards-row {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card {
      background: var(--bg-alt);
      border-radius: var(--card-radius);
      padding: 14px 14px 16px;
      box-shadow: var(--shadow-soft);
      border: 1px solid rgba(255,255,255,0.06);
    }

    .card-title {
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      opacity: 0.9;
      margin-bottom: 8px;
    }

    .text-block {
      font-size: 12px;
      line-height: 1.55;
      opacity: 0.88;
    }

    .status-line {
      font-size: 12px;
      margin-bottom: 4px;
    }

    /* ==================== MÓDULO ESTADO CAUSAL ==================== */
    .causal-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      background: rgba(148,163,184,0.15);
      border: 1px solid rgba(148,163,184,0.5);
    }

    .causal-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: #9ca3af;
      box-shadow: 0 0 8px rgba(156,163,175,0.8);
    }

    /* ==================== ANIMACIONES ==================== */
    @keyframes spin-slow {
      from { transform: rotate(0deg); }
      to   { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
<div class="shell">

  <!-- RELOJ CAUSAL GRANDE -->
  <div class="big-clock" id="bigClock">
    <svg viewBox="0 0 1000 800" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="gradRing" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" stop-color="#00E5FF"/>
          <stop offset="50%" stop-color="#40FF9C"/>
          <stop offset="100%" stop-color="#FF00FF"/>
        </linearGradient>
        <linearGradient id="gradNeedle" x1="0%" y1="100%" x2="0%" y2="0%">
          <stop offset="0%" stop-color="#35e0ff"/>
          <stop offset="100%" stop-color="#ffffff"/>
        </linearGradient>
        <filter id="glow">
          <feGaussianBlur stdDeviation="6" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>

      <!-- Fondo -->
      <circle cx="500" cy="400" r="380" fill="#0b0f1f"/>
      <circle cx="500" cy="400" r="375"
              stroke="url(#gradRing)" stroke-width="10"
              fill="none" opacity="0.7"/>

      <!-- Dial giratorio lento -->
      <g id="dialSpin" transform="translate(500,400)"
         style="animation: spin-slow 48s linear infinite;">
        <circle r="340" fill="none" stroke="#40FF9C"
                stroke-width="2" stroke-dasharray="8 16"
                opacity="0.4"/>
        <circle r="300" fill="none" stroke="#35e0ff"
                stroke-width="1" stroke-dasharray="4 12"
                opacity="0.3"/>
      </g>

      <!-- Encabezado espectro -->
      <g id="freqScale">
        <text x="500" y="70" fill="#9CA3AF" font-size="24" text-anchor="middle">
          Espectro de aceleración
        </text>
        <text x="500" y="100" fill="#60a5ff" font-size="18" text-anchor="middle"
              id="peakFreqText">0.00 Hz</text>
      </g>

      <!-- Aguja t_C principal -->
      <line id="tcNeedle"
            x1="500" y1="400" x2="500" y2="150"
            stroke="url(#gradNeedle)" stroke-width="8"
            stroke-linecap="round"
            transform="rotate(-60 500 400)"/>

      <!-- Aguja de frecuencia pico (FFT) -->
      <line id="freqNeedle"
            x1="500" y1="400" x2="500" y2="110"
            stroke="#ff6bff" stroke-width="5"
            stroke-linecap="round"
            opacity="0.9" filter="url(#glow)"/>

      <!-- Centro -->
      <circle cx="500" cy="400" r="20" fill="#00E5FF"/>
      <circle cx="500" cy="400" r="12" fill="#020617"/>
      <text x="500" y="415"
            fill="#E5E7EB" font-size="32"
            text-anchor="middle" font-weight="bold">
        t_C
      </text>
    </svg>
  </div>

  <!-- TARJETAS: ESTADO CAUSAL + ESTADO NUMÉRICO -->
  <div class="cards-row">
    <!-- Estado causal interpretado -->
    <div class="card">
      <div class="card-title">Estado causal actual</div>
      <div class="causal-badge">
        <span class="causal-dot" id="causalStateDot"></span>
        <span id="causalStateLabel">Esperando datos…</span>
      </div>
      <p class="text-block" id="causalStateText" style="margin-top:8px;">
        Mantén el teléfono quieto unos segundos y luego muévelo suavemente.
      </p>
    </div>

    <!-- Estado numérico básico -->
    <div class="card">
      <div class="card-title">Lecturas actuales</div>
      <p class="status-line">
        Aceleración total |a|:
        <strong id="magLive">0.00</strong> m/s²
      </p>
      <p class="status-line">
        Frecuencia dominante:
        <strong id="peakLive">0.00</strong> Hz
      </p>
      <p class="status-line">
        Resolución FFT:
        <strong id="resLive">0.00</strong> Hz/bin
      </p>
      <p class="status-line">
        ΔH (proxy):
        <strong id="dHLive">0.00</strong>
      </p>
      <p class="status-line">
        LI (proxy):
        <strong id="LILive">0.00</strong>
      </p>
      <p class="status-line">
        R (proxy):
        <strong id="RLive">0.00</strong>
      </p>
    </div>
  </div>

</div>

<script>
  // ================== ELEMENTOS SVG Y DOM ==================
  const bigClock      = document.getElementById('bigClock');
  const tcNeedle      = document.getElementById('tcNeedle');
  const freqNeedle    = document.getElementById('freqNeedle');
  const peakFreqText  = document.getElementById('peakFreqText');

  const magLiveEl = document.getElementById('magLive');
  const peakLiveEl = document.getElementById('peakLive');
  const resLiveEl = document.getElementById('resLive');
  const dHLiveEl  = document.getElementById('dHLive');
  const LILiveEl  = document.getElementById('LILive');
  const RLiveEl   = document.getElementById('RLive');

  const causalStateDot   = document.getElementById('causalStateDot');
  const causalStateLabel = document.getElementById('causalStateLabel');
  const causalStateText  = document.getElementById('causalStateText');

  // ================== VARIABLES Σ-METRICS (PROXIES) ==================
  let current_tC   = 0; // proxy: normalizado 0–1 desde |a|
  let current_LI   = 0; // proxy: locking index (bajo std → alto LI)
  let current_R    = 0; // proxy: coef. correlación aproximado
  let current_dH   = 0; // proxy: “entropía” (std normalizada)
  let current_aMag = 0; // |a| instantánea

  // ================== BUFFER Y FFT ==================
  let accelBuffer = [];
  let timestamps  = [];
  let N           = 512;
  let sampleRate  = 0;

  let lastTime = 0;

  function fft(real, imag) {
    const n = real.length;
    if (n <= 1) return;
    let levels = -1;
    for (let i = 0; i < 32; i++) {
      if (1 << i === n) { levels = i; break; }
    }
    if (levels === -1) return;

    // bit-reversal
    for (let i = 0; i < n; i++) {
      let j = 0;
      for (let k = 0; k < levels; k++) j = (j << 1) | ((i >> k) & 1);
      if (j > i) {
        [real[i], real[j]] = [real[j], real[i]];
        [imag[i], imag[j]] = [imag[j], imag[i]];
      }
    }

    // Cooley–Tukey
    for (let size = 2; size <= n; size <<= 1) {
      const angle = -2 * Math.PI / size;
      const wr = Math.cos(angle);
      const wi = Math.sin(angle);
      for (let i = 0; i < n; i += size) {
        let wpr = 1, wpi = 0;
        for (let j = 0; j < size / 2; j++) {
          const k = i + j;
          const l = k + size / 2;
          const tr = real[l] * wpr - imag[l] * wpi;
          const ti = real[l] * wpr + imag[l] * wpi;
          real[l] = real[k] - tr;
          imag[l] = imag[k] - ti;
          real[k] += tr;
          imag[k] += ti;
          const temp = wpr * wr - wpi * wi;
          wpi = wpr * wi + wpi * wr;
          wpr = temp;
        }
      }
    }
  }

  function computeSpectrum() {
    if (accelBuffer.length < N || sampleRate <= 0) return;

    const slice = accelBuffer.slice(-N);
    const mean  = slice.reduce((a, b) => a + b, 0) / N;

    const real = slice.map(v => v - mean);
    const imag = new Array(N).fill(0);

    fft(real, imag);

    const half = N >>> 1;
    let maxMag = 0;
    let peakBin = 0;

    for (let i = 1; i < half; i++) {
      const mag = Math.hypot(real[i], imag[i]);
      if (mag > maxMag) {
        maxMag = mag;
        peakBin = i;
      }
    }

    const freqResolution = sampleRate / N;
    const peakFreq = peakBin * freqResolution;
    const fMax     = sampleRate / 2;

    // Actualizar aguja de frecuencia pico → mapeo 0–60 Hz a -150..+150°
    const fRef = Math.max(1, Math.min(60, fMax || 60));
    const normF = Math.max(0, Math.min(peakFreq / fRef, 1));
    const angleF = -150 + normF * 300;
    freqNeedle.setAttribute('transform', `rotate(${angleF} 500 400)`);

    // Textos
    peakFreqText.textContent = peakFreq.toFixed(2) + ' Hz';
    peakLiveEl.textContent   = peakFreq.toFixed(2) + ' Hz';
    resLiveEl.textContent    = freqResolution.toFixed(3) + ' Hz/bin';

    // ---------- PROXIES Σ-METRICS DESDE STD ----------
    let variance = 0;
    for (let i = 0; i < N; i++) {
      const d = slice[i] - mean;
      variance += d * d;
    }
    variance /= N;
    const std = Math.sqrt(variance);

    // stdNorm ~ [0,1] para std aprox 0–5 m/s²
    const stdNorm = Math.max(0, Math.min(std / 5, 1));

    // ΔH proxy: [-0.5, +0.5] (baja std → ΔH negativo)
    current_dH = -0.5 + stdNorm;

    // LI y R proxys: más altos cuando la señal es “apretada”
    current_LI = 1 - stdNorm;
    current_R  = 0.5 + 0.5 * (1 - stdNorm);

    if (dHLiveEl) dHLiveEl.textContent = current_dH.toFixed(3);
    if (LILiveEl) LILiveEl.textContent = current_LI.toFixed(3);
    if (RLiveEl)  RLiveEl.textContent  = current_R.toFixed(3);

    updateCausalState();
  }

  // ================== ESTADO CAUSAL (SEMÁFORO) ==================
  function updateCausalState() {
    if (!causalStateDot || !causalStateLabel || !causalStateText) return;

    const entropy_ok = current_dH <= -0.2; // E-Veto proxy
    const locking_ok = current_LI >= 0.9 && current_R > 0.95;
    const strongMotion = current_aMag > 3.0; // umbral crude para “agitación”

    let mode = 'baseline';

    if (locking_ok && entropy_ok) {
      mode = 'ventana_q';
    } else if (strongMotion || current_dH >= 0) {
      mode = 'ruido';
    } else {
      mode = 'baseline';
    }

    if (mode === 'baseline') {
      causalStateDot.style.background = '#9ca3af';
      causalStateDot.style.boxShadow  = '0 0 8px rgba(156,163,175,0.9)';
      causalStateLabel.textContent    = 'Baseline φ-driven';
      causalStateText.textContent     =
        'El reloj está midiendo fricción / ruido de fondo. Útil como línea base antes de buscar coherencia.';
    } else if (mode === 'ruido') {
      causalStateDot.style.background = '#f97316';
      causalStateDot.style.boxShadow  = '0 0 10px rgba(249,115,22,0.9)';
      causalStateLabel.textContent    = 'Movimiento entrópico';
      causalStateText.textContent     =
        'Sistema en agitación fuerte o entropía creciente (ΔH ≥ 0). Es poco probable que haya locking estable aquí.';
    } else if (mode === 'ventana_q') {
      causalStateDot.style.background = '#22c55e';
      causalStateDot.style.boxShadow  = '0 0 12px rgba(34,197,94,0.9)';
      causalStateLabel.textContent    = 'Ventana candidata Q-driven';
      causalStateText.textContent     =
        'Los indicadores sugieren una ventana coherencial (locking_ok & ΔH ≤ -0.2). Candidata para análisis más fino.';
    }
  }

  // ================== MANEJADOR DE ACELERACIÓN ==================
  function handleMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const ax = a.x || 0;
    const ay = a.y || 0;
    const az = a.z || 0;
    const mag = Math.hypot(ax, ay, az);

    const now = performance.now();
    if (lastTime > 0) {
      const dt = (now - lastTime) / 1000;
      if (dt > 0) sampleRate = 1 / dt;
    }
    lastTime = now;

    current_aMag = mag;

    // t_C proxy (aguja principal) → norm 0–1 desde |a|
    const norm = Math.min(mag / 20, 1);
    current_tC = norm;
    const tcAngle = -60 + norm * 120;
    tcNeedle.setAttribute('transform', `rotate(${tcAngle} 500 400)`);

    // Buffer para FFT
    accelBuffer.push(mag);
    timestamps.push(now);
    if (accelBuffer.length > 4096) {
      accelBuffer.shift();
      timestamps.shift();
    }

    if (magLiveEl) magLiveEl.textContent = mag.toFixed(2);

    computeSpectrum();
  }

  // ================== INICIO ==================
  async function init() {
    try {
      if (typeof DeviceMotionEvent !== 'undefined' &&
          typeof DeviceMotionEvent.requestPermission === 'function') {
        const perm = await DeviceMotionEvent.requestPermission();
        if (perm !== 'granted') {
          alert('Permiso de sensores denegado.');
          return;
        }
      }
      window.addEventListener('devicemotion', handleMotion);
      bigClock.classList.add('ready');
    } catch (err) {
      console.error('Error al iniciar sensores:', err);
    }
  }

  // Primer toque → activar
  document.body.addEventListener('click', init, { once: true });
  document.body.addEventListener('touchstart', init, { once: true });
</script>
</body>
</html>
