<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Reloj Causal Humano — TCDS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #050713;
      --fg: #f5f7ff;
      --accent: #35e0ff;
      --accent2: #ff6bff;
      --ring: #40ff9c;
      --card-radius: 24px;
      --shadow-soft: 0 26px 60px rgba(0,0,0,0.7);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Roboto", "Segoe UI", sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #141b33 0%, #050713 45%, #01010a 100%);
      color: var(--fg);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px;
    }

    .shell {
      width: 100%;
      max-width: 1100px;
      margin: auto;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .big-clock {
      background: radial-gradient(circle at center, #182546 0%, #050713 70%);
      border-radius: 32px;
      padding: 20px;
      box-shadow: var(--shadow-soft);
      border: 1px solid rgba(255,255,255,0.08);
      position: relative;
      overflow: hidden;
    }

    .big-clock.ready {
      box-shadow:
        0 0 30px rgba(56,189,248,0.7),
        0 0 80px rgba(59,130,246,0.9);
    }

    .big-clock svg {
      display: block;
      width: 100%;
      height: auto;
    }

    .status-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      font-size: 12px;
      opacity: 0.9;
    }

    .status-chip {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.6);
    }

    @keyframes spin-slow { 
      from { transform: rotate(0deg); } 
      to   { transform: rotate(360deg); } 
    }
  </style>
</head>
<body>
<div class="shell">
<div class="card" id="sonarCard">
  <div class="card-title">Sonar Causal — Distancia por eco</div>

  <div class="text-block">
    Este experimento emite un breve <em>chirp</em> por el altavoz del teléfono
    y escucha los ecos con el micrófono para estimar la distancia al objeto
    más cercano que refleje el sonido.
  </div>

  <button class="btn" id="sonarBtn">Emitir ping y medir</button>

  <div class="text-block" style="margin-top:10px;">
    Distancia estimada: <strong id="sonarDistance">—</strong><br>
    Calidad del eco (coef. correlación): <strong id="sonarQuality">—</strong>
  </div>

  <div class="text-block" id="sonarStatus" style="font-size:11px; opacity:0.8;">
    Esperando primer ping…
  </div>

  <div class="log" id="sonarLog" style="margin-top:8px; max-height:120px;">
    <!-- Aquí se irán apilando las últimas mediciones -->
  </div>
</div>

  <div class="big-clock" id="bigClock">
    <svg viewBox="0 0 1000 800" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="gradRing" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" stop-color="#00E5FF"/>
          <stop offset="50%" stop-color="#40FF9C"/>
          <stop offset="100%" stop-color="#FF00FF"/>
        </linearGradient>
        <linearGradient id="gradNeedleTC" x1="0%" y1="100%" x2="0%" y2="0%">
          <stop offset="0%" stop-color="#35e0ff"/>
          <stop offset="100%" stop-color="#ffffff"/>
        </linearGradient>
        <linearGradient id="gradNeedleF" x1="0%" y1="100%" x2="0%" y2="0%">
          <stop offset="0%" stop-color="#ff6bff"/>
          <stop offset="100%" stop-color="#ffffff"/>
        </linearGradient>
        <filter id="glow">
          <feGaussianBlur stdDeviation="6" result="blur" />
          <feMerge>
            <feMergeNode in="blur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>

      <!-- Fondo -->
      <circle cx="500" cy="400" r="380" fill="#020617"/>
      <circle cx="500" cy="400" r="370" stroke="url(#gradRing)" stroke-width="10" fill="none" opacity="0.8"/>

      <!-- Dial dinámico (sólo decoración) -->
      <g id="dialSpin" transform="translate(500,400)" style="animation: spin-slow 48s linear infinite;">
        <circle r="320" fill="none" stroke="#40FF9C" stroke-width="2" stroke-dasharray="8 18" opacity="0.4"/>
        <circle r="280" fill="none" stroke="#35e0ff" stroke-width="1" stroke-dasharray="4 14" opacity="0.3"/>
      </g>

      <!-- Escala t_C (interior, -60° a +60°) -->
      <g id="scaleTC">
        <text x="500" y="190" fill="#9CA3AF" font-size="18" text-anchor="middle">t_C · |a| normalizado</text>
        <!-- Marcas principales (mismo aro, pero interpretado como t_C) -->
        <g stroke="#35e0ff" stroke-width="3">
          <!-- -60° -->
          <line x1="268" y1="531" x2="292" y2="507"/>
          <!-- 0° -->
          <line x1="500" y1="650" x2="500" y2="620"/>
          <!-- +60° -->
          <line x1="732" y1="531" x2="708" y2="507"/>
        </g>
      </g>

      <!-- Escala de frecuencia (misma corona, lectura para aguja magenta) -->
      <g id="scaleF">
        <text x="500" y="140" fill="#9CA3AF" font-size="18" text-anchor="middle">f_dom(|a|) [Hz]</text>
        <!-- 0 Hz en eje vertical superior -->
        <line x1="500" y1="60" x2="500" y2="90" stroke="#ff6bff" stroke-width="3"/>
        <text x="500" y="110" fill="#ff6bff" font-size="14" text-anchor="middle">0</text>
        <!-- Marcas de referencia (5, 10, 20 Hz) sólo como guía conceptual -->
        <text x="830" y="410" fill="#ff6bff" font-size="12" text-anchor="middle">≈ f alta</text>
      </g>

      <!-- Aguja t_C (aceleración total) -->
      <line id="tcNeedle" x1="500" y1="400" x2="500" y2="160"
            stroke="url(#gradNeedleTC)" stroke-width="10" stroke-linecap="round"
            transform="rotate(-60 500 400)" filter="url(#glow)"/>

      <!-- Aguja de frecuencia dominante (FFT de |a|) -->
      <line id="freqNeedle" x1="500" y1="400" x2="500" y2="120"
            stroke="url(#gradNeedleF)" stroke-width="6" stroke-linecap="round"
            transform="rotate(0 500 400)" filter="url(#glow)" opacity="0.95"/>

      <!-- Centro / Σ -->
      <circle cx="500" cy="400" r="26" fill="#020617" stroke="#00E5FF" stroke-width="3"/>
      <circle cx="500" cy="400" r="18" fill="#00E5FF"/>
      <text x="500" y="405" fill="#020617" font-size="18" font-weight="700" text-anchor="middle">Σ</text>

      <!-- Texto base -->
      <text x="500" y="460" fill="#E5E7EB" font-size="26" text-anchor="middle" font-weight="600">
        Reloj Causal Humano — TCDS
      </text>
      <text x="500" y="490" fill="#9CA3AF" font-size="14" text-anchor="middle">
        Q · Σ = φ  ·  t_C(t) desde sensores del dispositivo
      </text>
    </svg>
  </div>

  <div class="status-bar">
    <div class="status-chip">
      |a|: <span id="magLive">0.00</span> m/s²
    </div>
    <div class="status-chip">
      t_C (aguja cian): <span id="tcAngleLive">-60.0</span>°
    </div>
    <div class="status-chip">
      f_dom (aguja magenta): <span id="peakLive">0.00</span> Hz
    </div>
    <div class="status-chip">
      Resolución FFT: <span id="resLive">0.00</span> Hz/bin
    </div>
  </div>

</div>

<script>
  // ==== Elementos clave ====
  const bigClock     = document.getElementById('bigClock');
  const tcNeedle     = document.getElementById('tcNeedle');
  const freqNeedle   = document.getElementById('freqNeedle');

  const magLiveEl    = document.getElementById('magLive');
  const tcAngleEl    = document.getElementById('tcAngleLive');
  const peakLiveEl   = document.getElementById('peakLive');
  const resLiveEl    = document.getElementById('resLive');

  // ==== Buffers para FFT sobre |a| ====
  let accelBuffer = [];
  let lastTime    = 0;
  let sampleRate  = 0;
  let N           = 512;  // tamaño de ventana FFT (potencia de 2)

  // FFT radix-2 simple
  function fft(real, imag) {
    const n = real.length;
    if (n <= 1) return;

    let levels = -1;
    for (let i = 0; i < 32; i++) {
      if (1 << i === n) { levels = i; break; }
    }
    if (levels < 0) return;

    // bit reversal
    for (let i = 0; i < n; i++) {
      let j = 0;
      for (let k = 0; k < levels; k++) {
        j = (j << 1) | ((i >> k) & 1);
      }
      if (j > i) {
        [real[i], real[j]] = [real[j], real[i]];
        [imag[i], imag[j]] = [imag[j], imag[i]];
      }
    }

    // Cooley–Tukey
    for (let size = 2; size <= n; size <<= 1) {
      const half = size >> 1;
      const step = -2 * Math.PI / size;
      for (let i = 0; i < n; i += size) {
        let wr = 1, wi = 0;
        for (let j = 0; j < half; j++) {
          const k = i + j;
          const l = k + half;

          const tr = real[l] * wr - imag[l] * wi;
          const ti = real[l] * wr + imag[l] * wi;

          real[l] = real[k] - tr;
          imag[l] = imag[k] - ti;
          real[k] += tr;
          imag[k] += ti;

          const tmp = wr * Math.cos(step) - wi * Math.sin(step);
          wi = wr * Math.sin(step) + wi * Math.cos(step);
          wr = tmp;
        }
      }
    }
  }

  function computeSpectrum() {
    if (accelBuffer.length < N || sampleRate <= 0) return;

    const slice = accelBuffer.slice(-N);
    const mean  = slice.reduce((a,b)=>a+b,0) / N;
    const real  = slice.map(v => v - mean);
    const imag  = new Array(N).fill(0);

    fft(real, imag);

    const half = N >> 1;
    let maxMag = 0;
    let peakBin = 0;

    for (let i = 1; i < half; i++) {
      const mag = Math.hypot(real[i], imag[i]);
      if (mag > maxMag) {
        maxMag = mag;
        peakBin = i;
      }
    }

    const fRes   = sampleRate / N;
    const fPeak  = peakBin * fRes;
    const fNyq   = sampleRate / 2;

    // Mapeo 0–fNyq → -150° a +150° (aguja magenta)
    const clamped = Math.max(0, Math.min(fPeak, fNyq));
    const frac    = fNyq > 0 ? clamped / fNyq : 0;
    const angleF  = -150 + 300 * frac;

    freqNeedle.setAttribute('transform', `rotate(${angleF} 500 400)`);

    peakLiveEl.textContent = fPeak.toFixed(2) + ' Hz';
    resLiveEl.textContent  = fRes.toFixed(3) + ' Hz/bin';
  }

  function handleMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const ax = a.x || 0;
    const ay = a.y || 0;
    const az = a.z || 0;
    const mag = Math.hypot(ax, ay, az);  // |a|

    const now = performance.now();
    if (lastTime > 0) {
      const dt = (now - lastTime) / 1000;
      if (dt > 0) sampleRate = 1 / dt;
    }
    lastTime = now;

    // t_C: mapeo simple 0–20 m/s² → -60° a +60°
    const maxG = 20;
    const norm = Math.max(0, Math.min(mag / maxG, 1));
    const angleTC = -60 + norm * 120;

    tcNeedle.setAttribute('transform', `rotate(${angleTC} 500 400)`);

    accelBuffer.push(mag);
    if (accelBuffer.length > 4096) accelBuffer.shift();

    magLiveEl.textContent = mag.toFixed(2);
    tcAngleEl.textContent = angleTC.toFixed(1);

    computeSpectrum();
  }

  async function initReloj() {
    try {
      if (typeof DeviceMotionEvent !== 'undefined' &&
          typeof DeviceMotionEvent.requestPermission === 'function') {
        const res = await DeviceMotionEvent.requestPermission();
        if (res !== 'granted') {
          alert('Permiso de movimiento denegado. El reloj no podrá leer t_C.');
          return;
        }
      }
      window.addEventListener('devicemotion', handleMotion);
      bigClock.classList.add('ready');
    } catch (err) {
      console.error('Error iniciando Reloj Causal:', err);
    }
  }

  // Primer toque → activación
  document.body.addEventListener('click', initReloj,   { once: true });
  document.body.addEventListener('touchstart', initReloj, { once: true });
</script>
</body>
</html>
