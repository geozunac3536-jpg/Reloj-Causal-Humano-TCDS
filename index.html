<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Reloj Causal Humano — TCDS v3.1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #050713;
      --fg: #f5f7ff;
      --accent: #35e0ff;
      --accent2: #ff6bff;
      --accent3: #a855f7;
      --accent4: #4ade80;
      --danger: #ff6b6b;
      --card-radius: 32px;
      --shadow-soft: 0 20px 50px rgba(0,0,0,0.7);
    }

    * { box-sizing: border-box; margin:0; padding:0; font-family: system-ui, sans-serif; }

    body {
      background: radial-gradient(circle at top, #141b33 0%, #050713 45%, #01010a 100%);
      color: var(--fg);
      min-height: 100dvh;
      padding: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .shell {
      max-width: 1100px;
      width: 100%;
    }

    .big-clock {
      background: radial-gradient(circle at center, #182546 0%, #050713 70%);
      border-radius: var(--card-radius);
      padding: 24px;
      box-shadow: var(--shadow-soft);
      border: 1px solid rgba(255,255,255,0.08);
      position: relative;
      overflow: hidden;
    }

    .big-clock svg {
      width: 100%;
      height: auto;
      display: block;
    }

    .big-clock.ready {
      box-shadow:
        0 0 30px rgba(56,189,248,0.7),
        0 0 80px rgba(59,130,246,0.9);
    }

    @keyframes spin-slow { to { transform: rotate(360deg); } }

    @keyframes batteryPulse {
      0%,100% { transform: scale(0.9); opacity: 0.7; }
      50%     { transform: scale(1.15); opacity: 1; }
    }

    #batteryDot {
      transform-origin: 500px 400px;
      animation: batteryPulse 2.0s ease-in-out infinite;
    }
  </style>
</head>
<body>
<div class="shell">
  <div class="big-clock" id="bigClock">
    <svg viewBox="0 0 1000 800" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="gradRing" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" stop-color="#00E5FF"/>
          <stop offset="50%" stop-color="#40FF9C"/>
          <stop offset="100%" stop-color="#FF00FF"/>
        </linearGradient>
        <linearGradient id="gradNeedleTC" x1="0%" y1="100%" x2="0%" y2="0%">
          <stop offset="0%" stop-color="#35e0ff"/>
          <stop offset="100%" stop-color="#ffffff"/>
        </linearGradient>
        <filter id="glow">
          <feGaussianBlur stdDeviation="6" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>

      <!-- Fondo general -->
      <circle cx="500" cy="400" r="380" fill="#050713"/>
      <circle cx="500" cy="400" r="375"
              stroke="url(#gradRing)" stroke-width="10" fill="none" opacity="0.5"/>

      <!-- Aros de escala -->
      <!-- Aceleración |a| / t_C (aro interior medio) -->
      <circle cx="500" cy="400" r="260"
              fill="none" stroke="#35e0ff" stroke-width="2"
              stroke-dasharray="6 10" opacity="0.4"/>
      <text x="500" y="190" fill="#9CA3AF" font-size="14" text-anchor="middle">
        |a| / t_C
      </text>

      <!-- Espectro aceleración (f_a pico, aro exterior) -->
      <circle cx="500" cy="400" r="320"
              fill="none" stroke="#ff6bff" stroke-width="2"
              stroke-dasharray="8 14" opacity="0.6"/>
      <text x="500" y="90" fill="#f472ff" font-size="14" text-anchor="middle">
        f_a pico (Hz)
      </text>
      <text id="accelFreqLabel" x="500" y="110"
            fill="#f9a8ff" font-size="18" text-anchor="middle">0.00</text>

      <!-- Espectro magnético (f_B pico, aro medio-externo) -->
      <circle cx="500" cy="400" r="340"
              fill="none" stroke="#a855f7" stroke-width="2"
              stroke-dasharray="4 10" opacity="0.6"/>
      <text x="500" y="720" fill="#a855f7" font-size="14" text-anchor="middle">
        f_B pico (Hz)
      </text>
      <text id="magFreqLabel" x="500" y="740"
            fill="#c4b5fd" font-size="16" text-anchor="middle">0.00</text>

      <!-- Altitud / velocidad vertical (aro interno) -->
      <circle cx="500" cy="400" r="220"
              fill="none" stroke="#4ade80" stroke-width="2"
              stroke-dasharray="5 10" opacity="0.6"/>
      <text x="150" y="400" fill="#4ade80" font-size="13" text-anchor="middle">
        Δh / v_z
      </text>
      <text id="altLabel" x="150" y="420"
            fill="#bbf7d0" font-size="11" text-anchor="middle">0.00 m</text>
      <text id="vzLabel" x="150" y="436"
            fill="#bbf7d0" font-size="11" text-anchor="middle">0.00 m/s</text>

      <!-- Ticks generados por JS -->
      <g id="accelTicks"></g>
      <g id="magTicks"></g>
      <g id="altTicks"></g>

      <!-- Dial giratorio decorativo -->
      <g id="dialSpin" transform="translate(500,400)">
        <circle r="300" fill="none" stroke="#1f2937"
                stroke-width="40" opacity="0.6"/>
        <circle r="300" fill="none" stroke="#111827"
                stroke-width="6" stroke-dasharray="12 18" opacity="0.7"
                style="animation: spin-slow 48s linear infinite;"/>
      </g>

      <!-- Aguja t_C (|a|) gruesa -->
      <line id="tcNeedle"
            x1="500" y1="400" x2="500" y2="170"
            stroke="url(#gradNeedleTC)" stroke-width="10"
            stroke-linecap="round"
            transform="rotate(-60 500 400)"
            filter="url(#glow)"/>

      <!-- Aguja frecuencia aceleración (f_a) -->
      <line id="accelFreqNeedle"
            x1="500" y1="400" x2="500" y2="60"
            stroke="#ff6bff" stroke-width="6"
            stroke-linecap="round"
            opacity="0.9" filter="url(#glow)"/>

      <!-- Aguja frecuencia magnética (f_B) -->
      <line id="magFreqNeedle"
            x1="500" y1="400" x2="500" y2="40"
            stroke="#a855f7" stroke-width="5"
            stroke-linecap="round"
            opacity="0.9" filter="url(#glow)"/>

      <!-- Aguja altímetro (Δh / v_z) -->
      <line id="altNeedle"
            x1="500" y1="400" x2="500" y2="160"
            stroke="#4ade80" stroke-width="6"
            stroke-linecap="round"
            opacity="0.9" filter="url(#glow)"/>

      <!-- Centro -->
      <circle cx="500" cy="400" r="24" fill="#020617" stroke="#00E5FF" stroke-width="3"/>
      <circle cx="500" cy="400" r="12" fill="#00E5FF"/>

      <!-- Indicador de batería en el centro -->
      <circle id="batteryDot" cx="500" cy="400" r="7" fill="#22c55e"/>

      <!-- Texto central t_C y métricas -->
      <text x="500" y="410" fill="#E5E7EB" font-size="26"
            text-anchor="middle" font-weight="bold">t_C</text>
      <text id="magLiveLabel" x="500" y="434"
            fill="#9CA3AF" font-size="14" text-anchor="middle">
        |a| = 0.00 m/s²
      </text>
      <text id="fsLabel" x="500" y="454"
            fill="#6b7280" font-size="11" text-anchor="middle">
        f_s ≈ 0.0 Hz
      </text>
    </svg>
  </div>
</div>

<script>
  // ========= ELEMENTOS SVG =========
  const bigClock        = document.getElementById('bigClock');
  const tcNeedle        = document.getElementById('tcNeedle');
  const accelFreqNeedle = document.getElementById('accelFreqNeedle');
  const magFreqNeedle   = document.getElementById('magFreqNeedle');
  const altNeedle       = document.getElementById('altNeedle');
  const batteryDot      = document.getElementById('batteryDot');

  const accelFreqLabel  = document.getElementById('accelFreqLabel');
  const magFreqLabel    = document.getElementById('magFreqLabel');
  const altLabel        = document.getElementById('altLabel');
  const vzLabel         = document.getElementById('vzLabel');
  const magLiveLabel    = document.getElementById('magLiveLabel');
  const fsLabel         = document.getElementById('fsLabel');

  const accelTicksGroup = document.getElementById('accelTicks');
  const magTicksGroup   = document.getElementById('magTicks');
  const altTicksGroup   = document.getElementById('altTicks');

  const CX = 500;
  const CY = 400;

  // ========= BUFFERS Y PARAMETROS =========
  let accelSamples = [];
  let accelTimes   = [];
  const N_ACCEL    = 512;
  const MAX_BUF    = 4096;
  let lastMotionTime = null;
  let accelFs = 0;

  // Magnetómetro
  let magSamples = [];
  let magTimes   = [];
  const N_MAG    = 256;
  let magFs      = 0;

  // Barómetro
  let baroP0 = null;
  let baroLastAlt = 0;
  let baroLastTime = null;

  // Batería
  let batteryInfo = { level: null, charging: null };

  // ========= FFT radix-2 =========
  function fftRadix2(re, im) {
    const n = re.length;
    const levels = Math.log2(n);
    if (Math.floor(levels) !== levels) return;

    for (let i = 0; i < n; i++) {
      let j = 0;
      for (let bit = 0; bit < levels; bit++) {
        j = (j << 1) | ((i >> bit) & 1);
      }
      if (j > i) {
        [re[i], re[j]] = [re[j], re[i]];
        [im[i], im[j]] = [im[j], im[i]];
      }
    }

    for (let size = 2; size <= n; size <<= 1) {
      const half = size >>> 1;
      const step = (Math.PI * 2) / size;
      for (let i = 0; i < n; i += size) {
        for (let j = 0; j < half; j++) {
          const k = i + j;
          const l = k + half;
          const angle = step * j;
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);

          const tre = re[l] * cos - im[l] * sin;
          const tim = re[l] * sin + im[l] * cos;

          re[l] = re[k] - tre;
          im[l] = im[k] - tim;
          re[k] += tre;
          im[k] += tim;
        }
      }
    }
  }

  // ========= MAPEO ANGULAR =========
  function mapFreqToAngle(freq, maxHz) {
    const f = Math.max(0, Math.min(freq, maxHz));
    return (f / maxHz) * 300 - 150; // 0..maxHz → -150..150°
  }

  function mapAltToAngle(h, hRange) {
    const clamped = Math.max(-hRange, Math.min(h, hRange));
    const n = (clamped + hRange) / (2 * hRange); // [-hR,hR] → [0,1]
    return n * 300 - 150; // → -150..150°
  }

  // ========= TICKS NUMÉRICOS (CÍRCULOS) =========
  function createFreqTicks(group, radius, maxHz, step, color) {
    if (!group) return;
    for (let f = 0; f <= maxHz; f += step) {
      const angleDeg = mapFreqToAngle(f, maxHz);
      const theta = angleDeg * Math.PI / 180;

      const innerR = radius - 10;
      const outerR = radius;
      const labelR = radius + 18;

      const x1 = CX + innerR * Math.sin(theta);
      const y1 = CY - innerR * Math.cos(theta);
      const x2 = CX + outerR * Math.sin(theta);
      const y2 = CY - outerR * Math.cos(theta);
      const xl = CX + labelR * Math.sin(theta);
      const yl = CY - labelR * Math.cos(theta);

      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      line.setAttribute('stroke', color);
      line.setAttribute('stroke-width', f % (step*2) === 0 ? 2.2 : 1.4);
      line.setAttribute('opacity', 0.8);
      group.appendChild(line);

      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('x', xl);
      text.setAttribute('y', yl);
      text.setAttribute('fill', color);
      text.setAttribute('font-size', '10');
      text.setAttribute('text-anchor', 'middle');
      text.textContent = f.toString();
      group.appendChild(text);
    }
  }

  function createAltTicks(group, radius, minVal, maxVal, step, color) {
    if (!group) return;
    const range = Math.max(Math.abs(minVal), Math.abs(maxVal));
    for (let h = minVal; h <= maxVal; h += step) {
      const angleDeg = mapAltToAngle(h, range);
      const theta = angleDeg * Math.PI / 180;

      const innerR = radius - 10;
      const outerR = radius;
      const labelR = radius + 16;

      const x1 = CX + innerR * Math.sin(theta);
      const y1 = CY - innerR * Math.cos(theta);
      const x2 = CX + outerR * Math.sin(theta);
      const y2 = CY - outerR * Math.cos(theta);
      const xl = CX + labelR * Math.sin(theta);
      const yl = CY - labelR * Math.cos(theta);

      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
      line.setAttribute('stroke', color);
      line.setAttribute('stroke-width', h % (step*2) === 0 ? 2.0 : 1.2);
      line.setAttribute('opacity', 0.85);
      group.appendChild(line);

      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('x', xl);
      text.setAttribute('y', yl);
      text.setAttribute('fill', color);
      text.setAttribute('font-size', '10');
      text.setAttribute('text-anchor', 'middle');
      text.textContent = h.toString();
      group.appendChild(text);
    }
  }

  // Crear ticks estáticos al cargar el documento
  createFreqTicks(accelTicksGroup, 320, 60, 10, '#f9a8ff'); // f_a
  createFreqTicks(magTicksGroup,   340, 60, 10, '#c4b5fd'); // f_B
  createAltTicks(altTicksGroup,    220,-10, 10, 5, '#bbf7d0'); // Δh

  // ========= ACELERÓMETRO / t_C =========
  function computeAccelSpectrum() {
    if (accelSamples.length < N_ACCEL) return;
    const start = accelSamples.length - N_ACCEL;
    const slice = accelSamples.slice(start);
    const times = accelTimes.slice(start);
    const N = slice.length;

    const tFirst = times[0];
    const tLast  = times[N - 1];
    const dt = (tLast - tFirst) / (N - 1 || 1) / 1000;
    if (dt > 0) accelFs = 1 / dt;

    const mean = slice.reduce((a,b)=>a+b,0)/N;
    const re = new Array(N);
    const im = new Array(N).fill(0);
    for (let i = 0; i < N; i++) re[i] = slice[i] - mean;

    fftRadix2(re, im);

    const half = Math.floor(N/2);
    let peakBin = 0;
    let peakAmp = 0;
    for (let k = 1; k <= half; k++) {
      const amp = Math.hypot(re[k], im[k]);
      if (amp > peakAmp) {
        peakAmp = amp;
        peakBin = k;
      }
    }

    const fRes = accelFs / N;
    const peakFreq = peakBin * fRes || 0;

    const angle = mapFreqToAngle(peakFreq, 60);
    accelFreqNeedle.setAttribute('transform', `rotate(${angle} 500 400)`);

    accelFreqLabel.textContent = peakFreq.toFixed(2);
    fsLabel.textContent = 'f_s ≈ ' + (accelFs || 0).toFixed(1) +
                          ' Hz · Δf ≈ ' + fRes.toFixed(3) + ' Hz';
  }

  function handleMotion(event) {
    const acc = event.accelerationIncludingGravity || {};
    const ax = acc.x || 0;
    const ay = acc.y || 0;
    const az = acc.z || 0;

    const mag = Math.sqrt(ax*ax + ay*ay + az*az);
    const now = performance.now();

    if (lastMotionTime != null) {
      const dt = (now - lastMotionTime) / 1000;
      if (dt > 0) accelFs = 1 / dt;
    }
    lastMotionTime = now;

    const norm = Math.min(mag / 20, 1);
    const tcAngle = -60 + norm * 120;
    tcNeedle.setAttribute('transform', `rotate(${tcAngle} 500 400)`);

    accelSamples.push(mag);
    accelTimes.push(now);
    if (accelSamples.length > MAX_BUF) {
      const excess = accelSamples.length - MAX_BUF;
      accelSamples.splice(0, excess);
      accelTimes.splice(0, excess);
    }

    magLiveLabel.textContent = '|a| = ' + mag.toFixed(2) + ' m/s²';

    computeAccelSpectrum();
  }

  async function initAccel() {
    try {
      if (typeof DeviceMotionEvent !== 'undefined' &&
          typeof DeviceMotionEvent.requestPermission === 'function') {
        const res = await DeviceMotionEvent.requestPermission();
        if (res !== 'granted') {
          console.warn('Permiso de movimiento denegado');
          return;
        }
      }
      window.addEventListener('devicemotion', handleMotion);
      bigClock.classList.add('ready');
    } catch (e) {
      console.error('Error init acelerómetro:', e);
    }
  }

  // ========= MAGNETÓMETRO =========
  function computeMagSpectrum() {
    if (magSamples.length < N_MAG) return;
    const start = magSamples.length - N_MAG;
    const slice = magSamples.slice(start);
    const times = magTimes.slice(start);
    const N = slice.length;

    const tFirst = times[0];
    const tLast  = times[N - 1];
    const dt = (tLast - tFirst) / (N - 1 || 1) / 1000;
    if (dt > 0) magFs = 1 / dt;

    const mean = slice.reduce((a,b)=>a+b,0)/N;
    const re = new Array(N);
    const im = new Array(N).fill(0);
    for (let i = 0; i < N; i++) re[i] = slice[i] - mean;

    fftRadix2(re, im);

    const half = Math.floor(N/2);
    let peakBin = 0;
    let peakAmp = 0;
    for (let k = 1; k <= half; k++) {
      const amp = Math.hypot(re[k], im[k]);
      if (amp > peakAmp) {
        peakAmp = amp;
        peakBin = k;
      }
    }

    const fRes = magFs / N;
    const peakFreq = peakBin * fRes || 0;

    const angle = mapFreqToAngle(peakFreq, 60);
    magFreqNeedle.setAttribute('transform', `rotate(${angle} 500 400)`);
    magFreqLabel.textContent = peakFreq.toFixed(2);
  }

  function initMagnetometer() {
    if (!('Magnetometer' in window)) {
      console.warn('Magnetometer API no disponible');
      magFreqLabel.textContent = 'N/D';
      return;
    }
    try {
      const sensor = new Magnetometer({ frequency: 25 });
      sensor.addEventListener('reading', () => {
        const Bx = sensor.x || 0;
        const By = sensor.y || 0;
        const Bz = sensor.z || 0;
        const mag = Math.sqrt(Bx*Bx + By*By + Bz*Bz);
        const t = performance.now();

        magSamples.push(mag);
        magTimes.push(t);
        if (magSamples.length > MAX_BUF) {
          const excess = magSamples.length - MAX_BUF;
          magSamples.splice(0, excess);
          magTimes.splice(0, excess);
        }

        computeMagSpectrum();
      });
      sensor.addEventListener('error', e => {
        console.error('Error Magnetometer:', e.error);
        magFreqLabel.textContent = 'Err';
      });
      sensor.start();
    } catch (e) {
      console.error('No se pudo iniciar Magnetometer:', e);
      magFreqLabel.textContent = 'N/D';
    }
  }

  // ========= BARÓMETRO =========
  function initBarometer() {
    if (!('Barometer' in window)) {
      console.warn('Barometer API no disponible');
      altLabel.textContent = 'N/D';
      vzLabel.textContent  = 'N/D';
      return;
    }
    try {
      const baro = new Barometer({ frequency: 5 });
      baro.addEventListener('reading', () => {
        const p = baro.pressure;
        const t = performance.now();

        if (baroP0 === null) {
          baroP0 = p;
          baroLastAlt  = 0;
          baroLastTime = t;
          return;
        }

        const h = 8434.5 * Math.log(baroP0 / p);
        let v = 0;
        if (baroLastTime != null && t !== baroLastTime) {
          const dt = (t - baroLastTime) / 1000;
          v = (h - baroLastAlt) / dt;
        }
        baroLastAlt  = h;
        baroLastTime = t;

        altLabel.textContent = h.toFixed(2) + ' m';
        vzLabel.textContent  = v.toFixed(2) + ' m/s';

        const angle = mapAltToAngle(h, 10); // ±10 m
        altNeedle.setAttribute('transform', `rotate(${angle} 500 400)`);
      });
      baro.addEventListener('error', e => {
        console.error('Error Barometer:', e.error);
        altLabel.textContent = 'Err';
        vzLabel.textContent  = 'Err';
      });
      baro.start();
    } catch (e) {
      console.error('No se pudo iniciar Barometer:', e);
      altLabel.textContent = 'N/D';
      vzLabel.textContent  = 'N/D';
    }
  }

  // ========= BATERÍA =========
  function applyBatteryStyle() {
    if (!batteryDot) return;
    const lvl = batteryInfo.level != null ? batteryInfo.level : 0.5;
    const minDur = 0.6;
    const maxDur = 3.0;
    const dur = maxDur - (maxDur - minDur) * lvl;
    batteryDot.style.animationDuration = dur.toFixed(2) + 's';

    if (lvl <= 0.2) {
      batteryDot.setAttribute('fill', '#f97373');
    } else if (lvl <= 0.5) {
      batteryDot.setAttribute('fill', '#fb923c');
    } else {
      batteryDot.setAttribute('fill', '#22c55e');
    }
  }

  function initBattery() {
    if (!navigator.getBattery) {
      console.warn('Battery API no disponible');
      return;
    }
    navigator.getBattery().then(b => {
      const update = () => {
        batteryInfo.level    = b.level;
        batteryInfo.charging = b.charging;
        applyBatteryStyle();
      };
      update();
      b.addEventListener('levelchange', update);
      b.addEventListener('chargingchange', update);
    }).catch(e => console.error('Error batería:', e));
  }

  // ========= INICIO GLOBAL =========
  function startAll() {
    initAccel();
    initMagnetometer();
    initBarometer();
    initBattery();
  }

  document.body.addEventListener('click', startAll,      { once:true });
  document.body.addEventListener('touchstart', startAll, { once:true });
</script>
</body>
  </html>
